End-to-End Flow: GitHub Copilot Agent with Custom MCP Server for Rally Integration
Overview
This document details the end-to-end workflow of a user interacting with GitHub Copilot's Agent Mode to execute tasks against Rally through a custom MCP (Model Context Protocol) server, including OAuth 2.1 authentication with PKCE.

Prerequisites
VS Code IDE with GitHub Copilot Agent Mode enabled

Custom MCP Server deployed on GCP

Rally OAuth application registration

mcp.json configuration file

Sequence Diagram

sequenceDiagram
    participant User as User (VSCode IDE)
    participant Agent as Copilot Agent
    participant MCP as MCP Server (GCP)
    participant Browser as User's Browser
    participant OAuth as OAuth Server (Rally)
    participant Rally as Rally API

    Note over User, Agent: Agent Initialization
    Agent->>Agent: Generate Session ID (e.g., UUID)
    Agent->>Agent: Store in env var (COPILOT_MCP_SESSION_ID)

    Note over User, Agent: User Issues Query
    User->>Agent: Chat: "Create a Rally story for task X"
    Agent->>Agent: Parse query, determine Rally MCP server from mcp.json

    Note over Agent, MCP: Initial Request with Session ID
    Agent->>MCP: POST /tools/create_rally_story<br>Headers: Session-ID: <session_id>, Content: query params
    MCP->>MCP: Check auth status for session_id (no token found)
    MCP-->>Agent: HTTP 401 + Auth Required + authURL (OAuth endpoint with state, code_challenge)

    Note over Agent, User: Prompt User for Auth
    Agent->>User: Display clickable authURL in chat
    User->>Browser: Click authURL (opens browser)

    Note over Browser, OAuth: OAuth Authentication in Browser
    Browser->>OAuth: GET authURL (with client_id, redirect_uri, state, code_challenge)
    OAuth->>User: Show login and consent screen
    User->>OAuth: Authenticate and consent
    OAuth-->>Browser: Redirect to MCP redirect_uri with code and state

    Note over Browser, MCP: Token Exchange by MCP Server
    Browser->>MCP: GET /oauth/callback?code=<code>&state=<state>
    MCP->>MCP: Validate state, link to session_id
    MCP->>OAuth: POST token endpoint (code, client_secret, code_verifier)
    OAuth-->>MCP: Access token and refresh token
    MCP->>MCP: Store tokens against session_id in database
    MCP-->>Browser: HTML response: "Auth success. Close browser."

    Note over User, Browser: User Returns to IDE
    Browser->>User: Display success message
    User->>Browser: Close browser window

    Note over Agent, MCP: Retry Original Request
    Agent->>MCP: POST /tools/create_rally_story<br>Headers: Session-ID: <session_id>, Content: query params
    MCP->>MCP: Find tokens for session_id
    MCP->>Rally: Authenticated API call (e.g., POST /story with access token)
    Rally-->>MCP: API response (e.g., story created)
    MCP->>MCP: Sanitize response if needed
    MCP-->>Agent: Tool result (success/failure)

    Note over Agent, User: Deliver Result to User
    Agent->>User: Display result in chat

The complete flow is illustrated in the following sequence diagram:

Step-by-Step Explanation
1. Agent Initialization in VSCode
When the Copilot Agent starts in VSCode:

Generates a unique Session ID (UUID)

Stores it in an environment variable (COPILOT_MCP_SESSION_ID)

This ID persists for the Agent's lifetime and identifies all requests from this IDE session

2. User Query
User types a query in Copilot chat requiring Rally interaction:

Example: "Create a Rally story for task X"

Copilot Agent parses the query and consults mcp.json to determine the appropriate MCP server

3. Initial Request to MCP Server
Agent sends a request to the Rally MCP server:

HTTP POST to /tools/create_rally_story

Includes Session-ID header with the value from COPILOT_MCP_SESSION_ID

Includes necessary parameters from the query

4. Authentication Check on MCP Server
MCP server processes the request:

Checks database for access token associated with the Session ID

Since no token exists (first request), responds with HTTP 401

Response includes OAuth authorization URL (authURL) with parameters:

client_id: Rally OAuth application ID

redirect_uri: MCP server's callback endpoint

state: Token linked to the Session ID

code_challenge: PKCE code challenge

5. User Authentication via Browser
User completes authentication:

Agent renders authURL as clickable link in chat

User clicks link, opening default browser to Rally OAuth page

User authenticates with Rally and grants required permissions

6. OAuth Redirect and Token Exchange
OAuth flow completion:

Rally OAuth server redirects to MCP server's redirect URI with authorization code and state

MCP server callback endpoint:

Validates state parameter (CSRF protection)

Retrieves associated Session ID

Exchanges authorization code for access token

Stores tokens in database mapped to Session ID

Returns HTML success page to browser

7. User Return to IDE
User returns to development environment:

Sees success message in browser

Closes browser window

8. Execution of Query
Agent completes the original request:

Automatically retries the original request with same Session ID

MCP server finds access token for Session ID

Makes authenticated API call to Rally

Sanitizes response if needed

Returns result to Agent

Agent displays result in chat

Key Points
Session ID Management: Generated once by Agent and used consistently to maintain state

OAuth Flow: MCP server acts as OAuth client, handling entire flow including PKCE

Retry Mechanism: Agent automatically retries after authentication completion

Security: PKCE prevents authorization code interception; state parameter binds authentication to request

Configuration Example (mcp.json)
json
{
  "mcpServers": {
    "rally-mcp-server": {
      "type": "http",
      "url": "https://rally-mcp-server.gcp.cloud",
      "headers": {
        "Session-ID": "$COPILOT_MCP_SESSION_ID"
      },
      "tools": ["get_rally_issue", "create_rally_defect"],
      "env": {
        "RALLY_OAUTH_CLIENT_ID": "COPILOT_MCP_RALLY_CLIENT_ID",
        "RALLY_OAUTH_CLIENT_SECRET": "COPILOT_MCP_RALLY_CLIENT_SECRET"
      }
    }
  }
}
Security Considerations
Tokens stored securely on MCP server, not on client

Context sanitization performed on MCP server before sending responses to Agent

Input validation and sanitization implemented on MCP server

Fine-grained authorization checks performed against Rally APIs

This workflow provides a secure, extensible pattern for integrating authenticated tools into the GitHub Copilot Agent experience.